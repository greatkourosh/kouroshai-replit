import asyncio
import sqlite3
from fastapi import APIRouter, HTTPException
import httpx
# from .service import create_task, get_tasks, update_task, delete_task
from .service import clean_code_response, get_gpt4o_response, validate_code
from pydantic import BaseModel
from datetime import datetime
from kouroshai.core.config import DEFAULT_MODEL, GITHUB_ENDPOINT, DB_PATH, OLLAMA_HOST, SUPPORTED_GITHUB_MODELS

import logging
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/codegen", tags=["codegen"])

# class TaskCreate(BaseModel):
#     title: str
#     description: str | None = None
#     status: str = "pending"

class CodeRequest(BaseModel):
    prompt: str
    model: str = "gpt-4o"

# @router.post("/")
# async def add_task(task: TaskCreate):
#     try:
#         task_id = await create_task(task.title, task.description, task.status)
#         return {"id": task_id, "message": "Task created"}
#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))

# @router.get("/")
# async def list_tasks():
#     return await get_tasks()


@router.post("")
async def generate_code_github(req: CodeRequest):
    """Generate code using GitHub Models API and store in database."""
    try:
        logger.info("Checking model availability for %s", req.model)
        if req.model not in SUPPORTED_GITHUB_MODELS:
            logger.error("Model %s not supported", req.model)
            raise HTTPException(status_code=400, detail=f"Model {req.model} not supported. Supported models: {SUPPORTED_GITHUB_MODELS}")
        
        code, error = await get_gpt4o_response(req.prompt, req.model)
        if error:
            logger.error("GitHub Models error: %s", error)
            raise HTTPException(status_code=500, detail=f"GitHub Models error: {error}")
        if not code:
            logger.error("Empty response from %s", req.model)
            raise HTTPException(status_code=500, detail=f"Empty response from {req.model}")

        code = clean_code_response(code.strip())
        is_valid = validate_code(code)
        logger.info("Code validation result: %s", is_valid)
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("INSERT INTO code_snippets (prompt, code, model) VALUES (?, ?, ?)",
                      (req.prompt, code, req.model))
        conn.commit()
        snippet_id = cursor.lastrowid
        conn.close()
        logger.info("Generated code for snippet_id %s", snippet_id)
        if not is_valid:
            return {"snippet_id": snippet_id, "code": code, "warning": "Code may contain syntax errors, check invalid_code.log"}
        return {"snippet_id": snippet_id, "code": code}
    except Exception as e:
        logger.error("Unexpected error: %s", str(e))
        raise HTTPException(status_code=500, detail=f"Failed to generate code: {str(e)}")

@router.post("/generate-code")
async def generate_code(req: CodeRequest):
    """Generate code using Ollama API and store in database with retry logic."""
    try:
        for attempt in range(3):
            try:
                async with httpx.AsyncClient(timeout=120.0) as client:
                    payload = {
                        "model": DEFAULT_MODEL,
                        "prompt": f"Generate a Python function for: {req.prompt}",
                        "stream": False
                    }
                    logger.info("Sending request to Ollama (attempt %s): %s", attempt + 1, payload)
                    response = await client.post(f"{OLLAMA_HOST}/api/generate", json=payload)
                    response.raise_for_status()
                    data = response.json()
                    code = clean_code_response(data.get("response", ""))
                    if not code:
                        logger.warning("No 'response' field in Ollama response")
                        raise HTTPException(status_code=500, detail="No code generated by Ollama")
                    is_valid = validate_code(code)
                    logger.info("Code validation result: %s", is_valid)
                    conn = sqlite3.connect(DB_PATH)
                    cursor = conn.cursor()
                    cursor.execute("INSERT INTO code_snippets (prompt, code, model) VALUES (?, ?, ?)",
                                  (req.prompt, code, DEFAULT_MODEL))
                    conn.commit()
                    snippet_id = cursor.lastrowid
                    conn.close()
                    logger.info("Generated code for snippet_id %s using %s", snippet_id, DEFAULT_MODEL)
                    if not is_valid:
                        return {"snippet_id": snippet_id, "code": code, "warning": "Code may contain syntax errors, check invalid_code.log"}
                    return {"snippet_id": snippet_id, "code": code}
            except httpx.RequestError as e:
                logger.warning("Attempt %s failed: %s", attempt + 1, str(e))
                if attempt == 2:
                    raise HTTPException(status_code=500, detail=f"Ollama API error: {str(e)}")
                await asyncio.sleep(1)
    except Exception as e:
        logger.error("Failed to generate code with Ollama: %s", str(e))
        raise HTTPException(status_code=500, detail=f"Failed to generate code: {str(e)}")

@router.get("/code-snippets")
async def get_code_snippets():
    """Retrieve all code snippets from the database."""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT id, prompt, code, model, created_at FROM code_snippets")
        snippets = cursor.fetchall()
        conn.close()
        logger.info("Fetched %s code snippets", len(snippets))
        return [{"id": s[0], "prompt": s[1], "code": s[2], "model": s[3], "created_at": s[4]} for s in snippets]
    except sqlite3.Error as e:
        logger.error("Failed to fetch snippets: %s", e)
        raise HTTPException(status_code=500, detail=f"Failed to fetch snippets: {str(e)}")
